import React from 'react';
import Link from '@docusaurus/Link';
import { useLocation } from '@docusaurus/router';
import {
  useDocsData,
  useActivePluginAndVersion,
} from '@docusaurus/plugin-content-docs/client';
// Alternative, often simpler for current sidebar:
// import { useDocsSidebar } from '@docusaurus/theme-common/internal';


import styles from './mobileDocSidebarContent.module.css'; // Ensure this file exists

// Updated SidebarItem interface to be more comprehensive
interface SidebarItem {
  type: 'link' | 'category' | 'doc' | 'html' | 'autogenerated'; // Docusaurus item types
  label?: string;
  href?: string;       // For links and resolved docs
  docId?: string;      // For items of type 'doc' before resolution
  items?: SidebarItem[]; // For categories
  value?: string;      // For HTML items
  // Add other common Docusaurus properties if needed:
  // collapsed?: boolean;
  // collapsible?: boolean;
  // className?: string;
  // customProps?: Record<string, any>;
}

// Helper component to recursively render sidebar items
function renderSidebarItems(items: SidebarItem[] | undefined, location: ReturnType<typeof useLocation>) {
  if (!items || items.length === 0) {
    return <p className={styles.noItems}>No items in this sidebar.</p>; // Or null
  }

  return (
    <ul className={styles.sidebarItemList}>
      {items.map((item, index) => {
        // Docusaurus might resolve 'doc' items to have an 'href' automatically.
        // If item.href is not present for 'doc', you might need to construct it or ensure docsData provides it.
        const href = item.href; // Or some logic if item.type === 'doc' and href is missing

        if (item.type === 'link' || item.type === 'doc') {
          if (!href) {
            console.warn('Sidebar item of type link/doc is missing href:', item);
            return null; // Skip rendering if no link
          }
          // Docusaurus Link component handles full URLs and relative paths correctly
          const isActive = location.pathname === href || location.pathname.startsWith(href + '/');
          return (
            <li key={item.label || href || index} className={styles.sidebarItemLink}>
              <Link
                to={href}
                className={isActive ? styles.activeLink : ''}
              >
                {item.label || 'Untitled Link'}
              </Link>
            </li>
          );
        } else if (item.type === 'category') {
          return (
            <li key={item.label || index} className={styles.sidebarItemCategory}>
              {/* Category label could be a collapsible header */}
              <h3 className={styles.categoryLabel}>{item.label || 'Untitled Category'}</h3>
              {/* Recursively render items within the category */}
              {renderSidebarItems(item.items, location)}
            </li>
          );
        } else if (item.type === 'html') {
          return (
            <li
              key={item.label || index}
              className={styles.sidebarItemHTML}
              dangerouslySetInnerHTML={{ __html: item.value || '' }}
            />
          );
        }
        // Handle other item types if necessary (e.g., 'autogenerated')
        // console.warn('Unhandled sidebar item type:', item.type, item);
        return null;
      })}
    </ul>
  );
}

export default function MobileDocSidebarContent() {
  const location = useLocation();
  const activePluginAndVersion = useActivePluginAndVersion();
  const activeDocsPluginId = activePluginAndVersion?.activePlugin?.pluginId;

  const docsData = useDocsData(activeDocsPluginId);
  console.log("docsData (all versions): ", docsData);

  const currentVersionData = docsData?.versions?.find(version => version.isLast);
  console.log("currentVersionData: ", currentVersionData);

  // *** This is the crucial part based on your data structure ***
  const rawSidebarObject = currentVersionData?.sidebars?.reactKitSidebar;
  console.log("rawSidebarObject (for 'reactKitSidebar'):", rawSidebarObject);

  let normalizedSidebarItems: SidebarItem[] = [];

  if (rawSidebarObject) {
    // Case 1: The sidebar is defined as { link: { path: '...', label: '...' } }
    // This structure comes directly from your provided data.
    if (rawSidebarObject.link && typeof rawSidebarObject.link === 'object') {
      normalizedSidebarItems = [{
        type: 'link', // We infer the type
        href: rawSidebarObject.link.path,
        label: rawSidebarObject.link.label,
      }];
    }
    // Case 2: The sidebar is already an array of standard items (more common)
    // e.g., reactKitSidebar: [ { type: 'doc', id: '...' }, ... ]
    else if (Array.isArray(rawSidebarObject)) {
      normalizedSidebarItems = rawSidebarObject as SidebarItem[];
    }
    // Case 3: The sidebar is a single standard item (not an array)
    // e.g., reactKitSidebar: { type: 'doc', id: '...' }
    else if (typeof rawSidebarObject === 'object' && rawSidebarObject.type) {
       normalizedSidebarItems = [rawSidebarObject as SidebarItem];
    }
     else {
      console.warn("Unrecognized sidebar structure for 'reactKitSidebar':", rawSidebarObject);
    }
  }

  console.log("normalizedSidebarItems to render:", normalizedSidebarItems);

  // --- ALTERNATIVE: Using useDocsSidebar (Often simpler) ---
  // const sidebar = useDocsSidebar(); // This gets the sidebar for the *current doc's page*
  // console.log("Sidebar from useDocsSidebar():", sidebar);
  // If using this, you'd pass `sidebar` to `renderSidebarItems` directly,
  // as it should already be in the correct `SidebarItem[]` format.
  // This hook is generally preferred if you just want the sidebar for the current context.
  // However, it might return `null` if no sidebar is associated with the current page.
  // --- End Alternative ---

  return (
    <div className={styles.mobileDocSidebarContainer}>
      {/* Optional: Title for the mobile sidebar */}
      <h2 className={styles.sidebarTitle}>Navigation</h2>
      <div className={styles.sidebarContent}>
        {normalizedSidebarItems.length > 0
          ? renderSidebarItems(normalizedSidebarItems, location)
          : <p className={styles.noSidebarMessage}>Sidebar not available or empty.</p>
        }
      </div>
    </div>
  );
}